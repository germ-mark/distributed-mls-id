



Messaging Layer Security                                          M. Xue
Internet-Draft                                        Germ Network, Inc.
Intended status: Informational                            J. W. Lukefahr
Expires: 23 April 2026                                           B. Hale
                                            US Naval Postgraduate School
                                                         20 October 2025


                            Distributed MLS
                    draft-xue-distributed-mls-latest

Abstract

   The Messaging Layer Security (MLS) protocol enables a group of
   participants to negotiate a common cryptographic state for messaging,
   providing Forward Secrecy (FS) and Post-Compromise Security (PCS).
   Still, there are some use cases where message ordering challenges may
   make it difficult for a group of participants to agree on a common
   state or use cases where reaching eventual consistency is impractical
   for the application.  This document describes Distributed-MLS (DMLS),
   a composition protocol for using MLS sessions to protect messages
   among participants without negotiating a common group state.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at https://germ-
   mark.github.io/distributed-mls-id/draft-xue-distributed-mls.html.
   Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-xue-distributed-mls/.

   Discussion of this document takes place on the Messaging Layer
   Security Working Group mailing list (mailto:mls@ietf.org), which is
   archived at https://mailarchive.ietf.org/arch/browse/mls/.  Subscribe
   at https://www.ietf.org/mailman/listinfo/mls/.

   Source for this draft and an issue tracker can be found at
   https://github.com/germ-mark/distributed-mls-id.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 23 April 2026.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Terminology
     1.2.  Protocol Overview
     1.3.  Meeting MLS Delivery Service Requirements
   2.  Send Group Operation
   3.  Group Operations
     3.1.  INIT
       3.1.1.  Over the wire definition
       3.1.2.  Application-directed definition
     3.2.  UPDATE
     3.3.  COMMIT
     3.4.  LEAF NODE UPDATE
     3.5.  PROTECT
     3.6.  UNPROTECT
   4.  DMLS Requirements
   5.  Wire Formats
   6.  Conventions and Definitions
   7.  Security Considerations
   8.  IANA Considerations
   9.  References
   10. Normative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   Participants operating in peer-to-peer or partitioned network
   topologies may find it impractical to access a centralized Delivery
   Service (DS), or reach consensus on message sequencing to arrive at a
   consistent Commit for each MLS epoch.

   DMLS is an composition or 'super'-group for facilitating group
   messaging in such use cases that uses MLS as a 'sub' protocol.  It
   instantiates an MLS session per participant, such that each
   participant acts as the 'owner' of its own group.  These sub-groups
   also act as 'Send Groups', in which the owner sends all of their
   application messages and determines the ordering of Proposals and
   Commits.  This allows each participant to locally and independently
   control the sequence of update processing and encrypt messages using
   MLS accordingingly.  A distributed group (DGroup) using DMLS then
   comprises the communication superset of such Send Groups.  This draft
   further addresses how to incorporate randomness from other
   participants' 'Send Groups' to ensure post-compromise security (PCS)
   is maintained across the superset.

1.1.  Terminology

   Send Group: An MLS session where one designated sender (the group
   'owner') authors all messages and other members use the group only to
   receive from the designated sender.

   DGroup: the set of communication participants, i.e., the superset of
   all associated Send Groups.

   DMembers: Members of the DGroup participating in the DMLS session,
   each as the owner of a Send Group.

1.2.  Protocol Overview

   Within a group distributed DMember participants, we can resolve state
   conflict by assigning each member local state that only they control.
   In DMLS, we assign to each DMember ownership of an MLS group that
   they then operate as a Send Group.  The Send Group owner can export
   secrets from other groups owned by DMembers and import such secrets
   as added randomness into their own Send Group through use of epochal
   Proposal messages.  This enables each Send Group to include entropy
   from other receive-only members of their Send Group, providing for
   both PCS and FS without the need to reach global consensus on
   ordering of updates.

1.3.  Meeting MLS Delivery Service Requirements

   The MLS Architecture Guide specifies two requirements for an abstract
   Delivery Service related to message ordering.  First, Proposal
   messages should all arrive before the Commit that references them.
   Second, members of an MLS group must agree on a single MLS Commit
   message that ends each epoch and begins the next one.

   An honest centralized DS, in the form of a message queuing server or
   content distribution network, can guarantee these requirements to be
   met.  By controlling the order of messages delivered to MLS
   participants, for example, it can guarantee that Commit messages
   always follow their associated Proposal messages.  By filtering
   Commit messages based on some pre-determined criteria, it can ensure
   that only a single Commit message per epoch is delivered to
   participants.

   A decentralized DS, on the other hand, can take the form of a message
   queuing server without specialized logic for handling MLS messages, a
   mesh network, or, perhaps, simply a local area network.  These DS
   instantiations cannot offer any such guarantees.

   The MLS Architecture Guide highlights the risk of two MLS members
   generating different Commits in the same epoch and then sending them
   at the same time.  The impact of this risk is inconsistency or
   forking of MLS group state among members, which in turn risks
   authorized members being unable to read each other's messages.  A
   decentralized DS offers no mitigation strategy for this risk, so the
   members themselves must agree on strategies, or in our terminology,
   operating constraints.  We could say in such cases that the full
   weight of the CAP theorem is therefor levied directly on the MLS
   members.  However, use cases exist that benefit from, or even
   necessitate, MLS and its accompanying security guarantees for
   distributed group communications.

   The DMLS operating constraints specified above allow honest members
   to form a distributed system that satisfies these requirements
   despite a decentralized DS.  Moreover, instead of mitigating or
   providing methods for resolving Commit collisions, it effectively
   eliminates any risk of them occuring.  It also, consequently removes
   the risk of insider state desyncronization attacks, as an insider (a
   DMember) can only control state in their own Send Group.  The Send
   Group methodology ensures that a single owner controls the Send
   sequence in their own group, including both application messages and
   Commits.  As a potential functional benefit in some use cases, DMLS
   further enables flexibility in receive-only modes, namely that any
   DiMember can continue to receive messages sent from other groups,
   even if not sending information themselves.

   Downsides of the DMLS design that may make it not suitable for all
   settings include increased overhead, namely due to the fact that
   within any Send Group, intermediate nodes along the parent path of
   any non-owner remain blank.  While the owner path updates when it
   Commits and other leaf nodes can be updated as explained later, the
   parent path of the other leaf nodes is not filled in.  Thus DMLS
   comes with functional trade-offs.

2.  Send Group Operation

   A DMLS Send Group operates in the following way: * The creator of the
   group, occupying leaf index 0, is the designated owner of the Send
   Group * Other members only accept messages from the owner * Members
   only accept messages as defined in Group Operations * Each group
   owner updates their contribution to the group with a full or empty
   Commit.  To incorporate fresh keying material inputs from another
   member, the group owner creates an exporter key from the other
   member's Send Group and imports the PSK into its own Send Group using
   a PSK Proposal.

   To facilitate binding Send Groups together, we define the following
   exported values: * derived groupid: MLS-Exporter("derivedGroupId",
   leafNodePublicSigningKey, Length)

  This is a unique value for each participant derived from the group's current epoch    * exportPSK: `MLS-Exporter("exporter-psk", "psk_id", KDF.Nh)`

3.  Group Operations

   Similar to MLS, DMLS provides a participant application programming
   interface (API) with the following functions:

3.1.  INIT

   Given a list of DMLS participants, DMembers, initialize an DMLS
   context by (1) creating an MLS group, (2) adding all other DMembers
   (generating a set of Welcome messages and a GroupInfo message).  It
   is the responsibility of a DMLS implementation to define the DMembers
   and the mechanism of generating the individual Send Groups.  Two
   possible approaches are described below.

3.1.1.  Over the wire definition

   For example, the DGroup can be defined over the wire by inferring it
   from a newly created Send Group.

   Assume Alice has keypackages for some other DMembers $M_i$

   Alice can construct a DGroup * with a randomly generated groupId *
   constructing a Commit adding all other DMembers $M_i$

   Alice can distribute the Welcome message with an Application Message
   that indicates * this is a Send Group for Alice * that defines the
   set of DMembers as the members of this group * with DMember
   identifier equal to the groupId for Alice's Send Group * and defines
   a common export key length

3.1.2.  Application-directed definition

   The DGroup set of DMembers can also be defined by the application
   layer, which provides each member: * keypackages for all other
   DMembers * a random set identifier for the DGroup * common export key
   length

   Keypackages can be reusable, e.g., marked as last-resort.
   Keypackages can also be single-use if the application layer retrieves
   at least $N-1$ (where $|U|=N$) unique keypackages from each member.

   Alice can construct her Send Group: * by creating an MLS group with
   randomly generated groupId * and then constructing a Commit and
   Welcome message adding all other DMembers

   With this approach, an additional message is not required as common
   configuration items are provided by the application layer.

3.2.  UPDATE

   A member Alice of DGroup can introduce new key material to other
   DMembers by authoring a full or empty Commit in Alice's own Send
   Group, which provides PCS with regard to the committer.

3.3.  COMMIT

   When Bob receives Alice's DMLS update (as a full or empty Commit in
   Alice's Send Group), Bob can incorporate PCS from Alice's Commit into
   his own Send Group by importing a PSK from Alice's Send Group.
   Precisely, Bob: * Creates a PSK Proposal in Bob's Send Group using
   the exportPskId and exportPSK from the epoch of Alice's Send Group
   after Alice's DMLS update * Bob generates a Commit covering the PSK
   Proposal * If other DMembers have updated in their respective Send
   Groups, Bob MAY include more than one PSK Proposal under the Commit
   in his own Send Group, corresponding to those respective updates.

   The psk_group_id for this PSK is more specifically defined as
   follows: psk_group_id = (opaque<8>) groupEpoch | groupId where
   epoch_bytes is the byte-vector representation of the epoch in which
   the exporter was generated, in network byte order.  Since epoch is of
   type uint64, this results in a fixed 8-byte vector. groupId, which is
   of type opaque<V>, is then appended to epoch_bytes.  When a
   exportPskId is received as part of an incoming PSK Proposal, it can
   then be processed as follows: groupId = exportPskId[8..] epoch =
   (uint64) exportPskId[0..7]

   Per [RFC9420], the psk_nonce MUST be a fresh random value of length
   KDF.Nh when the PSK Proposal is generated.  This ensures key
   separation between the PSKs generated, for example, by Bob and
   Charlie as DMembers when extracting PSKs from Alice's Send Group for
   creating Proposals within their own respective Send Groups.

3.4.  LEAF NODE UPDATE

   When Bob incporates PCS from Alice's Commit into his own Send Group
   by importing a PSK from Alice's Send Group, it is also critical that
   the associated leaf node changes are also updated in Bob's Send
   Group.

   Thus, when Bob creates a psk_group_id as defined above, it directly
   references a specific groupID and epoch from Alice's Send Group,
   which itself corresponds to the current leaf node of Alice for that
   epoch.  When Bob generates a Commit covering the PSK Proposal, Bob
   MUST also update Alice's leaf node within Bob's own Send Group to
   match the leaf node of Alice for the given groupID and epoch.  When
   other DMembers receiving messages in Bob's Send Group receive the
   Commit, they MUST also update their tree representations to reflect
   Alice's leaf node corresponding to the groupID and epoch.

   Alice's leaf node placement in Bob's own MLS tree MAY be different
   than in Alice' MLS tree, and consequently the Alice's update within
   her own Send Group does not correspond to intermediate node updates
   for Alice's path in Bob's Send Group.  Only the leaf node is updated.

3.5.  PROTECT

   A member Bob protects a ciphertext message and encrypts it to the
   DMembers by encrypting it as an application message in his Send
   Group, as in MLS.  As in MLS, before encrypting an application
   message, Bob SHOULD incorporate any DMLS updates of Bob's own or PSK
   proposals corresponding to updates in other DMember Send Groups that
   he has observed.

   Each of the 3 MLS configurations of Commit are possible: * If Bob has
   observed no updates but wishes to issue an update, Bob can author an
   empty Commit.  If Bob has observed DMLS updates in others' Send
   Groups, * Bob can incorporate those updates without an update of his
   own with a partial Commit covering PSK Proposals he derives from each
   of the other updated Send Groups. * Alternatively, Bob can
   incorporate those updates as well as an update of Bob's own by
   covering those PSK Proposals with a full Commit.

3.6.  UNPROTECT

   On receipt of an MLS message, a member can look up the corresponding
   Send Group by the MLS groupId in the message metadata and decrypt it
   with the keys associated with that Send Group.

4.  DMLS Requirements

   The application layer over MLS has the responsibility to define * The
   set of DMembers within DGroup for the DMLS session * Mapping groupIds
   to members of DGroup * Additional common rules, such as accepted
   cipher suites

   (Nothing inherently requires the Send Groups to agree on a cipher
   suite - each sender could choose their own, suitable to their own
   data transmission protection requirements, as long as they agree on
   export key length.  It is advisable that the application set minimum
   requirements for all Send Groups within the DGroup.)

   The DMLS application SHOULD recommend a policy for issuing DMLS
   updates.

5.  Wire Formats

   DMLS uses standard wire formats as defined in [RFC9420].  An
   application using DMLS SHOULD define formats for any additional
   messages containing common configuration or operational parameters.

6.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

7.  Security Considerations

   DMLS inherits and matches MLS in most security considerations with
   one notable change to security control nuances.  In MLS each group
   member can largely control when their updates will be introduced to
   the group state, with deconfliction only down to the DS.  In
   contrast, in DMLS the Send Group owner controls when key update
   material is included from each member; namely, every member updates
   in their own Send Group and fresh keying material is then imported to
   other Send Groups through use of the exporter key and PSK Proposal
   option, with timing controlled by the respective Send Group owners.
   This means that while the PCS healing frequency of a given member in
   MLS is under their own control, in DMLS the PCS healing frequency and
   timeliness of PSK import is controlled by the Send Group owner.
   However, the Send Group owner is also the only member sending data in
   the Send Group.  This means that there is a natural incentive to
   update frequently and in a timely manner, and that PCS impacts on
   sending of data are not delayed from the point of original update.

   FS guarantees per Send Group follow similarly; the Send Group owner
   determines the frequency of key roll-over.

   Notably, since the Send Group owner determines what is introduced as
   a PSK from other DMembers, it is not possible for an insider threat
   to disrupt the group state and cause desynchronization of the group
   view.  This is unlike in MLS, where all contributing parties must
   behave honestly to avoid state disruption.

   As in MLS, it is essential for PCS security that all members update
   frequently.  In MLS, if a member Bob does not receive the update from
   another member, Alice, Bob's state will become desynchronized from
   the rest of the MLS group, leading Bob to be unable to send messages
   that other group members (which have correctly processed Alice's
   updates) will be able to decrypt and also prevent Bob from decrypting
   messages received by those members.  Bob must obtain the missing
   Alice update from the DS.  In DMLS, however, the removal of
   desynchronization risk means that Bob will continue to be able to
   send messages to DMembers in Bob's Send Group even if Bob has not yet
   observed Alice's update.  This presents both a benefit and a risk, as
   a denial-of-service attacker that has compromised Alice's state could
   prevent Bob from receiving Alice's PCS update, meaning that Bob
   continues to send messages accessible under Alice's compromised state
   even after Alice has updated.  To prevent this, the application
   SHOULD specify minimal update frequency and Send Group owners SHOULD
   remove members from which no update has been observed for an
   excessive period.

8.  IANA Considerations

   This document has no IANA actions.

9.  References

   CAPBR: # Brewer, E., "Towards robust distributed systems (abstract)",
   ACM, Proceedings of the nineteenth annual ACM symposium on Principles
   of distributed computing, DOI 10.1145/343477.343502, July 2000,
   https://doi.org/10.1145/343477.343502
   (https://doi.org/10.1145/343477.343502).

10.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9420]  Barnes, R., Beurdouche, B., Robert, R., Millican, J.,
              Omara, E., and K. Cohn-Gordon, "The Messaging Layer
              Security (MLS) Protocol", RFC 9420, DOI 10.17487/RFC9420,
              July 2023, <https://www.rfc-editor.org/rfc/rfc9420>.

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Mark Xue
   Germ Network, Inc.
   Email: mark@germ.network


   Joseph W. Lukefahr
   US Naval Postgraduate School
   Email: joseph.lukefahr@nps.edu


   Britta Hale
   US Naval Postgraduate School
   Email: britta.hale@nps.edu
